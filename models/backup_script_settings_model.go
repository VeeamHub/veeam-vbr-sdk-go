// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BackupScriptSettingsModel Pre-freeze and post-thaw scripts.
//
// swagger:model BackupScriptSettingsModel
type BackupScriptSettingsModel struct {

	// linux scripts
	LinuxScripts *BackupLinuxScriptModel `json:"linuxScripts,omitempty"`

	// script processing mode
	// Required: true
	ScriptProcessingMode *EBackupScriptProcessingMode `json:"scriptProcessingMode"`

	// windows scripts
	WindowsScripts *BackupWindowsScriptModel `json:"windowsScripts,omitempty"`
}

// Validate validates this backup script settings model
func (m *BackupScriptSettingsModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinuxScripts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScriptProcessingMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWindowsScripts(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupScriptSettingsModel) validateLinuxScripts(formats strfmt.Registry) error {
	if swag.IsZero(m.LinuxScripts) { // not required
		return nil
	}

	if m.LinuxScripts != nil {
		if err := m.LinuxScripts.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("linuxScripts")
			}
			return err
		}
	}

	return nil
}

func (m *BackupScriptSettingsModel) validateScriptProcessingMode(formats strfmt.Registry) error {

	if err := validate.Required("scriptProcessingMode", "body", m.ScriptProcessingMode); err != nil {
		return err
	}

	if err := validate.Required("scriptProcessingMode", "body", m.ScriptProcessingMode); err != nil {
		return err
	}

	if m.ScriptProcessingMode != nil {
		if err := m.ScriptProcessingMode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scriptProcessingMode")
			}
			return err
		}
	}

	return nil
}

func (m *BackupScriptSettingsModel) validateWindowsScripts(formats strfmt.Registry) error {
	if swag.IsZero(m.WindowsScripts) { // not required
		return nil
	}

	if m.WindowsScripts != nil {
		if err := m.WindowsScripts.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("windowsScripts")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this backup script settings model based on the context it is used
func (m *BackupScriptSettingsModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinuxScripts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScriptProcessingMode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWindowsScripts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupScriptSettingsModel) contextValidateLinuxScripts(ctx context.Context, formats strfmt.Registry) error {

	if m.LinuxScripts != nil {
		if err := m.LinuxScripts.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("linuxScripts")
			}
			return err
		}
	}

	return nil
}

func (m *BackupScriptSettingsModel) contextValidateScriptProcessingMode(ctx context.Context, formats strfmt.Registry) error {

	if m.ScriptProcessingMode != nil {
		if err := m.ScriptProcessingMode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scriptProcessingMode")
			}
			return err
		}
	}

	return nil
}

func (m *BackupScriptSettingsModel) contextValidateWindowsScripts(ctx context.Context, formats strfmt.Registry) error {

	if m.WindowsScripts != nil {
		if err := m.WindowsScripts.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("windowsScripts")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackupScriptSettingsModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackupScriptSettingsModel) UnmarshalBinary(b []byte) error {
	var res BackupScriptSettingsModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
