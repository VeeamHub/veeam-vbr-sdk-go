// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CapacityTierModel Capacity tier.
//
// swagger:model CapacityTierModel
type CapacityTierModel struct {

	// If *true*, Veeam Backup & Replication copies backups from the performance extents to the capacity extent as soon as the backups are created.
	CopyPolicyEnabled bool `json:"copyPolicyEnabled,omitempty"`

	// If *true*, the capacity tier is enabled.
	Enabled bool `json:"enabled,omitempty"`

	// encryption
	Encryption *BackupStorageSettingsEncryptionModel `json:"encryption,omitempty"`

	// ID of an object storage repository added as a capacity extent.
	// Format: uuid
	ExtentID strfmt.UUID `json:"extentId,omitempty"`

	// If *true*, Veeam Backup & Replication moves backup files that belong to inactive backup chains from the performance extents to the capacity extent.
	MovePolicyEnabled bool `json:"movePolicyEnabled,omitempty"`

	// offload window
	OffloadWindow *BackupWindowSettingModel `json:"offloadWindow,omitempty"`

	// Number of days after which inactive backup chains on the performance extents are moved to the capacity extent. Specify *0* to offload inactive backup chains on the same day they are created.
	OperationalRestorePeriodDays int64 `json:"operationalRestorePeriodDays,omitempty"`

	// override policy
	OverridePolicy *CapacityTierOverridePolicyModel `json:"overridePolicy,omitempty"`
}

// Validate validates this capacity tier model
func (m *CapacityTierModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEncryption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExtentID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOffloadWindow(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverridePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CapacityTierModel) validateEncryption(formats strfmt.Registry) error {
	if swag.IsZero(m.Encryption) { // not required
		return nil
	}

	if m.Encryption != nil {
		if err := m.Encryption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption")
			}
			return err
		}
	}

	return nil
}

func (m *CapacityTierModel) validateExtentID(formats strfmt.Registry) error {
	if swag.IsZero(m.ExtentID) { // not required
		return nil
	}

	if err := validate.FormatOf("extentId", "body", "uuid", m.ExtentID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CapacityTierModel) validateOffloadWindow(formats strfmt.Registry) error {
	if swag.IsZero(m.OffloadWindow) { // not required
		return nil
	}

	if m.OffloadWindow != nil {
		if err := m.OffloadWindow.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offloadWindow")
			}
			return err
		}
	}

	return nil
}

func (m *CapacityTierModel) validateOverridePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.OverridePolicy) { // not required
		return nil
	}

	if m.OverridePolicy != nil {
		if err := m.OverridePolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("overridePolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capacity tier model based on the context it is used
func (m *CapacityTierModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEncryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOffloadWindow(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverridePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CapacityTierModel) contextValidateEncryption(ctx context.Context, formats strfmt.Registry) error {

	if m.Encryption != nil {
		if err := m.Encryption.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption")
			}
			return err
		}
	}

	return nil
}

func (m *CapacityTierModel) contextValidateOffloadWindow(ctx context.Context, formats strfmt.Registry) error {

	if m.OffloadWindow != nil {
		if err := m.OffloadWindow.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offloadWindow")
			}
			return err
		}
	}

	return nil
}

func (m *CapacityTierModel) contextValidateOverridePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.OverridePolicy != nil {
		if err := m.OverridePolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("overridePolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CapacityTierModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CapacityTierModel) UnmarshalBinary(b []byte) error {
	var res CapacityTierModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
